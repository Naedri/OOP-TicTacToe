BILAN :

Ce dossier est un travail collaboratif en binôme. La programmation orientée objet nous a permis de répartir le travail de manière ordonnée, chacun pouvant s’occuper d’une classe, donc d’une extension de TicTacToe. Nos différences de niveau, mais aussi nos différentes manières d’aborder un problème, nous ont imposé de commenter en détail chacune de nos méthodes et de leur trouver des noms explicites. Ces commentaires et ces noms ont favorisé l’utilisation des méthodes héritées et programmées par chacun de nous, ce qui a permis de factoriser une partie de notre code dès le début du projet.
L’évolution de nos connaissances basées sur les cours et les TD nous ont fait prendre conscience de certaines faiblesses de notre programme en cours de réalisation. Ces acquis ont progressivement modifié notre code, et plus particulièrement les dépendances et héritages entre nos différentes classes. Ces différents concepts clefs de programmation objet mis en œuvre dans notre projet, et les problèmes rencontrés sont décrits ci-dessous.
Encapsulation et protection des données : 

Les différents jeux sont répartis en classes. La seule possibilité d’interagir avec leurs données est d’utiliser les méthodes déclarées publiques. De cette manière, l’utilisateur de jouerJeu ne peut pas changer son score, où changer la disposition des symboles autrement qu’en jouant un coup. De plus l’utilisation de l’énumération Symbole nous garantit que la grille ne sera remplie qu’avec les symboles autorisés. 
Déﬁnir une hiérarchie de classes :

Etant donné les similarités entre les différentes applications. Nous avons pris le parti de faire hériter toutes nos classes de la classe abstraite JeuxDeGrille qui implémente l’interace JeuxAbstrait. Après avoir fait la liste des méthodes qui étaient indispensables pour pouvoir jouer une partie. Nous avons identifié les méthodes qui devaient être abstraites, et celles qui pouvaient être définies. La classe JeuxDeGrille représente le squelette à partir duquel les autres applications sont conçues. Ainsi une méthode comme estFini() est abstraite, car les conditions de fin de partie varient selon l’application et la classe abstraite n’a pas connaissance des règles. Par contre les méthodes comme placerJeton() ou toString() ont elles été codées car il nous a semblé que de nombreuses applications pourraient en tirer profit, quitte à les spécialiser si besoin. Il nous a aussi semblé pertinent de faire hériter les classes MorpionFormes et MorpionRandom de la classe Morpion car ces jeux sont très similaires et nous avons pu ainsi factoriser du code. 

Exploiter le sous-typage et favoriser le polymorphisme en évitant des dépendances vers les sous-classes d’une hiérarchie :

Le package JeuxAlignement est indépendant des autres packages, une interface est placée au sommet de la hiérarchie. La classe jouerJeu ne dépend que de cette interface. Toutes nos applications fonctionnent à partir des méthodes de l’interface au sommet de la hiérarchie, nous tirons donc pleinement parti du polymorphisme et de la subsomption dans notre classe JouerJeu. 
En somme nous avons implémentés toutes les applications qui nous étaient demandés, en essayant de garder une structure cohérente et un code concis et clair.
Pistes d’améliorations et difficultés rencontrées :

La plus grande difficulté a été l’application Morpion, car nous ne voulions pas ajouter de symboles en minuscules dans notre énumération (on ne doit pouvoir mettre dans la grille que les X et O prévus). Il a donc fallu trouver un moyen de garder la trace des coordonnées fermées sans toucher au contenu de la grille, et laisser l’affichage faire la conversion. Cela a aussi été pénalisant pour l’application avec permutation de deux symboles, car nous devions changer leurs places, mais aussi mettre à jour en conséquence la liste des coordonnées fermées. L’utilisation d’une grille de booléens pour mémoriser les coordonnées fermées nous a permis de garder des données cohérentes (les symboles dans la grille) mais a rendu le code plus complexe et moins lisible. La méthode coupGagnant() de la classe MorpionRandom gagnerait à être plus courte et plus simple. Contrairement aux autres applications, la grille est remplie dès le début et nous ne pouvions plus vérifier l’intégralité de la grille à la recherche d’un alignement comme nous ne le faisions dans les autres applications. Pour pallier ce problème, nous ne vérifions plus que les alentours des symboles permutés. 

